---
layout: post
title:  "this"
author: Bhushan Goel
categories: [ Javascript ]
tags: [ this, execution-context ]
companies: [ To The New, HCL, Walmart]
description: "`this` is basically a function context and its value depends on the style of function invocation."
featured: true
image: assets/images/js.png
comments: false
toc: true
---

<!-- [Rule 1](#standalone-function-invocation) -->

`this` refers to the **current function execution context** and its value depends on the style of `function invocation`.

It is a very important and confusing concept and a lot of questions can be asked which can be answered correctly only if you know the concept very well.

First, we need to find that **how the function is invoked** and based on that we need to apply one of the _four rules_ to find out the value of `this` inside any function -

- **Rule 1:** [Standalone function invocation](#rule-1-standalone-function-invocation) - behaviour is different in `strict` or `non-strict` mode
- **Rule 2:** [Invoked as an object method](#rule-2-invoked-as-an-object-method)
- **Rule 3:** Invoked using `call(), apply()`
- **Rule 4:** Invoked using `new` keyword

With the introduction of ES6, the value of `this` is now also dependent on the way a function is created - 

- **Function type** - `arrow functions` or `normal functions`
- **Classes** - `non-static method` or `static method`

Now, let us look at those rules in detail with the help of examples.

## Rule 1: Standalone function invocation
It is the most common case of function invocation.

According to this rule, if the function is invoked without any object reference or any other bindings. The value of `this` will be equal to - 
- `window` in `non-strict` mode
- `undefined` in `strict` mode


### `non-strict` mode

Here, we simply created a function `foo` and when we invoke it in the `non-strict` mode, `this` resolves to the `global object`.

```js
function foo() {
    console.log(this);  // [window]
}

foo();
```

Similarly, If declare a variable `var a = 2;`, in the global scope, it is same as adding a variable `a` inside a global scope. So, when we invoke `foo` in this case it prints `2` which was assigned to `var a`.

```js
function foo() {
    console.log(this.a);  // 2
    console.log(window.a);  // 2, [because, this = window]
}
var a = 2;

foo();
```

In these examples `Rule 1` is applied, because we are calling `foo()` without any bindings and also nothing is present on the left side of the `foo()` call.

### strict mode
If we try to execute the same code in `strict` mode, we will always get `this` as `undefined`.

```js
'use strict';
function foo() {
    console.log(this);  // undefined [because, this !== window]
    console.log(window.a);  // 2, [because, `a` is created on global window object]
}
var a = 2;

foo();
```

## Rule 2: Invoked as an object method

If we invoke a function as a `method`(_function defined inside an object is known as method_), then value of `this` inside a `method` is always equal to the `object`.
```js
var obj = {
    a: 2,
    // foo is declared as a method
    foo: function() {
        // returning the current value of `this`
        return this;
    }
}

// Way 1
console.log(obj.foo());     // obj{} -> {a: 2, foo: [f]}
console.log(obj.foo() === obj);     // true
console.log(obj.foo().a);   // 2

// Way 2
// We can also store the object into a variable
// returned by invoking the method 
var bar = obj.foo();
console.log(bar);   // obj{} -> {a: 2, foo: [f]}
console.log(bar === obj);     // true
console.log(bar.a);     // 2 
```
This is how invokation of an `object method` works, but in **interviews** this question can be asked in a different way, as shown in the example below -

```js
// Way 3
var obj = {
    a: 2,
    // foo is declared as a method
    foo: function() {
        // returning the current value of `this`
        return this;
    }
}

var bar = obj.foo;
// invoked as a standalone function(Rule 1)
console.log(bar());   // [window(non-strict mode), undefined(strict mode)]
console.log(bar === obj);     // false
console.log(bar.a);     // undefined
```

Every thing is same as that of previous example, only on _line 11_, we are storing the reference of the function in a variable instead of invoking it. 

<details>
<summary><b>Question 1:</b> What will get printed in the <code>console</code>(_line 13, 14, 15_)?</summary>
<div markdown="1">
You can tell the interviewer that -
<br>
<br>
When we try to invoke that method at a later point(<i>line 12</i>), then instead of pointing to the object(<code>obj</code>), it will be equal to <code>global object</code> or <code>undefined</code>.
<br>
<br>
Why?
<br>
<br>
Because, In case of `object method` whenever we store the reference of the function in a variable, the **binding of the object is lost** and function will be invoked as a standalone function (<a href="#rule-1-standalone-function-invocation">Rule 1</a>) at a later stage.
<br>
<br>
</div>
</details>
<br>

<details>
<summary><b>Question 2:</b> How can we fix this code?</summary>
<div markdown="1">
After storing the reference to the method, we lost the binding to `this`. Now to fix this binding issue we need to use <code>bind()</code> -
<br>
<br>
<div markdown="1">
```js
var obj = {
    a: 2,
    // foo is declared as a method
    foo: function() {
        // returning the current value of `this`
        return this;
    }
}

var bar = obj.foo.bind(obj);
// invoked as a standalone function(Rule 1)
console.log(bar());   // {a: 2, foo: [f]}
console.log(bar() === obj);     // true
console.log(bar().a); 	// 2
```
</div>
</div>
</details>
<br>

> There is a simpler way to identify the current execution context in case of **Rule 1** and **Rule 2**.
>
> You can check if there is something present on the **left-hand side** of the function invocation and 
>
> - if yes, then `this` will be equal to that `object`, 
> - otherwise if nothing is present on the left-hand side then `this` will be equal to either `global object` or `undefined`

## Cheat sheet
There is a trick that can be used to answer most of the input-output questions in an interview. You just need to check two things - 
- Is there any `explicit binding` is present on the function invocation - `fn.call(), fn.apply(), fn.bind()`
- Is there any `object` present on the `left side` of the function invocation - `obj.method()`

If none of them is present, than you need to look if the code is in the `strict` mode or `non-strict` mode.
- In non-strict mode - `this = window`
- In strict mode - `this = undefined`

You can refer this flow chart
![this-flow-chart](https://raw.githubusercontent.com/bhushangoel/ctfi-cdn/a2b79ac268983709380eb696959791d4f7d17887/Flow%20chart-this.png#post-img)